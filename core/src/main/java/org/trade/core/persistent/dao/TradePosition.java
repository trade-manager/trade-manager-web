/* ===========================================================
 * TradeManager : a application to trade strategies for the Java(tm) platform
 * ===========================================================
 *
 * (C) Copyright 2011-2011, by Simon Allen and Contributors.
 *
 * Project Info:  org.trade
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 * [Java is a trademark or registered trademark of Oracle, Inc.
 * in the United States and other countries.]
 *
 * (C) Copyright 2011-2011, by Simon Allen and Contributors.
 *
 * Original Author:  Simon Allen;
 * Contributor(s):   -;
 *
 * Changes
 * -------
 *
 */
package org.trade.core.persistent.dao;

// Generated Feb 21, 2011 12:43:33 PM by Hibernate Tools 3.4.0.CR1

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import jakarta.persistence.Transient;
import org.trade.core.dao.Aspect;
import org.trade.core.valuetype.Money;
import org.trade.core.valuetype.Side;

import java.io.Serial;
import java.math.BigDecimal;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.List;


/**
 * Trade generated by hbm2java
 *
 * @author Simon Allen
 * @version $Revision: 1.0 $
 */
@Entity
@Table(name = "tradeposition")
public class TradePosition extends Aspect implements java.io.Serializable {

    /**
     * There can only ever be one TradePosition open at a time for a Contract. A
     * TradePosition is created when at least one TradeOrder becomes
     * filled/partially filled.
     * <p>
     * The TradeOrder that caused the TradePosition to be created is marked as
     * the opening TradeOrder.
     * <p>
     * A TradePosition is closed when the total open quantity i.e. buy quantity
     * less sell quantity equals zero. At this point the net value represents
     * the P/L for the position.
     */

    @Serial
    private static final long serialVersionUID = 715993951200025530L;

    @Column(name = "position_open_date", nullable = false)
    private ZonedDateTime positionOpenDate;

    @Column(name = "side", nullable = false, length = 3)
    private String side;

    @Column(name = "last_update_date", nullable = false)
    private ZonedDateTime lastUpdateDate;

    @Column(name = "open_quantity")
    private Integer openQuantity = 0;

    @Column(name = "position_close_date")
    private ZonedDateTime positionCloseDate;

    @Column(name = "total_commission", precision = 10)
    private BigDecimal totalCommission;

    @Column(name = "total_buy_quantity")
    private Integer totalBuyQuantity;

    @Column(name = "total_buy_value", precision = 10)
    private BigDecimal totalBuyValue;

    @Column(name = "total_sell_quantity")
    private Integer totalSellQuantity;

    @Column(name = "total_sell_value", precision = 10)
    private BigDecimal totalSellValue;

    @Column(name = "total_net_value", precision = 10)
    private BigDecimal totalNetValue;

    @OneToMany(mappedBy = "tradePosition", fetch = FetchType.LAZY, cascade = {CascadeType.REFRESH,
            CascadeType.REMOVE})
    private List<TradeOrder> tradeOrders = new ArrayList<>(0);

    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "contract_id", nullable = false)
    private ContractLite contract;

    public TradePosition() {
    }

    /**
     * Constructor for TradePosition.
     *
     * @param contract         Contract
     * @param positionOpenDate Date
     * @param side             String
     */
    public TradePosition(Contract contract, ZonedDateTime positionOpenDate, String side) {

        this.contract = new ContractLite(contract.getId());
        this.positionOpenDate = positionOpenDate;
        this.side = side;
        this.lastUpdateDate = positionOpenDate;
    }

    /**
     * Constructor for TradePosition.
     *
     * @param contract         Contract
     * @param positionOpenDate Date
     * @param side             String
     */
    public TradePosition(ContractLite contract, ZonedDateTime positionOpenDate, String side) {

        this.contract = contract;
        this.positionOpenDate = positionOpenDate;
        this.side = side;
        this.lastUpdateDate = positionOpenDate;
    }

    /**
     * Constructor for TradePosition.
     *
     * @param contract          Contract
     * @param positionOpenDate  Date
     * @param positionCloseDate Date
     * @param openQuantity      Integer
     * @param side              String
     * @param totalBuyQuantity  Integer
     * @param totalBuyValue     BigDecimal
     * @param totalSellQuantity Integer
     * @param totalSellValue    BigDecimal
     * @param totalNetValue     BigDecimal
     * @param tradeOrders       List<TradeOrder>
     */
    public TradePosition(Contract contract, ZonedDateTime positionOpenDate, ZonedDateTime positionCloseDate,
                         Integer openQuantity, String side, BigDecimal totalCommission, Integer totalBuyQuantity,
                         BigDecimal totalBuyValue, Integer totalSellQuantity, BigDecimal totalSellValue, BigDecimal totalNetValue,
                         List<TradeOrder> tradeOrders) {

        this.contract = new ContractLite(contract.getId());
        this.positionOpenDate = positionOpenDate;
        this.positionCloseDate = positionCloseDate;
        this.openQuantity = openQuantity;
        this.side = side;
        this.totalCommission = totalCommission;
        this.totalBuyQuantity = totalBuyQuantity;
        this.totalBuyValue = totalBuyValue;
        this.totalSellQuantity = totalSellQuantity;
        this.totalSellValue = totalSellValue;
        this.totalNetValue = totalNetValue;
        this.tradeOrders = tradeOrders;
        this.lastUpdateDate = positionOpenDate;
    }

    /**
     * Method getContract.
     *
     * @return ContractLite
     */
    public ContractLite getContract() {
        return this.contract;
    }

    /**
     * Method setContract.
     *
     * @param contract ContractLite
     */
    public void setContract(ContractLite contract) {
        this.contract = contract;
    }

    /**
     * Method getPositionOpenDate.
     *
     * @return ZonedDateTime
     */
    public ZonedDateTime getPositionOpenDate() {
        return this.positionOpenDate;
    }

    /**
     * Method setPositionOpenDate.
     *
     * @param positionOpenDate ZonedDateTime
     */
    public void setPositionOpenDate(ZonedDateTime positionOpenDate) {
        this.positionOpenDate = positionOpenDate;
    }

    /**
     * Method getPositionCloseDate.
     *
     * @return ZonedDateTime
     */
    public ZonedDateTime getPositionCloseDate() {
        return this.positionCloseDate;
    }

    /**
     * Method setPositionCloseDate.
     *
     * @param positionCloseDate ZonedDateTime
     */
    public void setPositionCloseDate(ZonedDateTime positionCloseDate) {
        this.positionCloseDate = positionCloseDate;
    }

    /**
     * Method getOpenQuantity.
     *
     * @return Integer
     */
    public Integer getOpenQuantity() {
        return this.openQuantity;
    }

    /**
     * Method setOpenQuantity.
     *
     * @param openQuantity Integer
     */
    public void setOpenQuantity(Integer openQuantity) {
        this.openQuantity = openQuantity;
    }

    /**
     * Method getSide.
     *
     * @return String
     */
    public String getSide() {
        return this.side;
    }

    /**
     * Method setSide.
     *
     * @param side String
     */
    public void setSide(String side) {
        this.side = side;
    }

    /**
     * Method getTotalCommission.
     *
     * @return BigDecimal
     */
    public BigDecimal getTotalCommission() {
        return this.totalCommission;
    }

    /**
     * Method setTotalCommission.
     *
     * @param totalCommission BigDecimal
     */
    public void setTotalCommission(BigDecimal totalCommission) {
        this.totalCommission = totalCommission;
    }

    /**
     * Method getTotalBuyQuantity.
     *
     * @return Integer
     */
    public Integer getTotalBuyQuantity() {
        return this.totalBuyQuantity;
    }

    /**
     * Method setTotalBuyQuantity.
     *
     * @param totalBuyQuantity Integer
     */
    public void setTotalBuyQuantity(Integer totalBuyQuantity) {
        this.totalBuyQuantity = totalBuyQuantity;
    }

    /**
     * Method getTotalSellQuantity.
     *
     * @return Integer
     */
    public Integer getTotalSellQuantity() {
        return this.totalSellQuantity;
    }

    /**
     * Method setTotalSellQuantity.
     *
     * @param totalSellQuantity Integer
     */
    public void setTotalSellQuantity(Integer totalSellQuantity) {
        this.totalSellQuantity = totalSellQuantity;
    }

    /**
     * Method getTotalBuyValue.
     *
     * @return BigDecimal
     */
    public BigDecimal getTotalBuyValue() {
        return this.totalBuyValue;
    }

    /**
     * Method setTotalBuyValue.
     *
     * @param totalBuyValue BigDecimal
     */
    public void setTotalBuyValue(BigDecimal totalBuyValue) {
        this.totalBuyValue = totalBuyValue;
    }

    /**
     * Method getTotalSellValue.
     *
     * @return BigDecimal
     */
    public BigDecimal getTotalSellValue() {
        return this.totalSellValue;
    }

    /**
     * Method setTotalSellValue.
     *
     * @param totalSellValue BigDecimal
     */
    public void setTotalSellValue(BigDecimal totalSellValue) {
        this.totalSellValue = totalSellValue;
    }

    /**
     * Method getTotalNetValue.
     *
     * @return BigDecimal
     */
    public BigDecimal getTotalNetValue() {
        return this.totalNetValue;
    }

    /**
     * Method setTotalNetValue.
     *
     * @param totalNetValue BigDecimal
     */
    public void setTotalNetValue(BigDecimal totalNetValue) {
        this.totalNetValue = totalNetValue;
    }

    /**
     * Method getLastUpdateDate.
     *
     * @return ZonedDateTime
     */
    public ZonedDateTime getLastUpdateDate() {
        return this.lastUpdateDate;
    }

    /**
     * Method setLastUpdateDate.
     *
     * @param lastUpdateDate ZonedDateTime
     */
    public void setLastUpdateDate(ZonedDateTime lastUpdateDate) {
        this.lastUpdateDate = lastUpdateDate;
    }

    /**
     * Method getTradeOrders.
     *
     * @return List<TradeOrder>
     */
    public List<TradeOrder> getTradeOrders() {
        return this.tradeOrders;
    }

    /**
     * Method setTradeOrders.
     *
     * @param tradeOrders List<TradeOrder>
     */
    public void setTradeOrders(List<TradeOrder> tradeOrders) {
        this.tradeOrders = tradeOrders;
    }

    /**
     * Method addTradeOrder.
     *
     * @param tradeOrders TradeOrder
     */
    public void addTradeOrder(TradeOrder tradeOrders) {
        this.tradeOrders.add(tradeOrders);
    }

    /**
     * Method isOpen.
     *
     * @return boolean
     */
    @Transient
    public boolean isOpen() {
        return this.equals(this.getContract().getTradePosition());
    }

    /**
     * Method containsTradeOrder.
     *
     * @param tradeOrder TradeOrder
     * @return boolean
     */
    @Transient
    public boolean containsTradeOrder(TradeOrder tradeOrder) {

        for (TradeOrder item : this.getTradeOrders()) {

            if (item.getOrderKey().equals(tradeOrder.getOrderKey())) {

                return true;
            }
        }
        return false;
    }

    /**
     * Method getUnRealizedProfit.
     *
     * @param lastPrice BigDecimal
     * @return BigDecimal
     */
    @Transient
    public BigDecimal getUnRealizedProfit(BigDecimal lastPrice) {

        double unRealizedProfit = 0;

        Integer prevIdTradePosition = null;

        for (TradeOrder order : getTradeOrders()) {

            if (order.getIsFilled()) {

                if (null == prevIdTradePosition
                        || !prevIdTradePosition.equals(order.getTradePosition().getId())) {

                    prevIdTradePosition = order.getTradePosition().getId();
                    if (order.getTradePosition().equals(order.getTradePosition().getContract().getTradePosition())) {
                        unRealizedProfit = order.getTradePosition().getTotalNetValue().doubleValue()
                                + (order.getTradePosition().getOpenQuantity() * lastPrice.doubleValue());

                    }
                }
            }
        }
        return new BigDecimal(unRealizedProfit);
    }

    /**
     * Method getRealizedProfit.
     *
     * @return BigDecimal
     */
    @Transient
    public BigDecimal getRealizedProfit() {

        double realizedProfit = 0;
        Integer prevIdTradePosition = null;

        for (TradeOrder order : getTradeOrders()) {

            if (order.getIsFilled()) {

                if (null == prevIdTradePosition
                        || !prevIdTradePosition.equals(order.getTradePosition().getId())) {

                    prevIdTradePosition = order.getTradePosition().getId();

                    if (order.getTradePosition().getTotalSellQuantity().doubleValue() > 0
                            && order.getTradePosition().getTotalBuyQuantity().doubleValue() > 0) {

                        double qty = (order.getTradePosition().getTotalSellQuantity().doubleValue()
                                - order.getTradePosition().getTotalBuyQuantity().doubleValue());

                        if (qty == 0) {
                            realizedProfit = realizedProfit + order.getTradePosition().getTotalNetValue().doubleValue()
                                    - order.getTradePosition().getTotalCommission().doubleValue();
                        } else {

                            double avgBuy = (order.getTradePosition().getTotalBuyValue().doubleValue()
                                    / order.getTradePosition().getTotalBuyQuantity().doubleValue());

                            double avgSell = (order.getTradePosition().getTotalSellValue().doubleValue()
                                    / order.getTradePosition().getTotalSellQuantity().doubleValue());

                            int sideVal = (Side.BOT.equals(order.getTradePosition().getSide()) ? -1 : 1);
                            realizedProfit = realizedProfit + (qty * (avgSell - avgBuy) * sideVal)
                                    - order.getTradePosition().getTotalCommission().doubleValue();
                        }
                    }
                }
            }
        }
        return new BigDecimal(realizedProfit);
    }

    /**
     * Method toString.
     *
     * @return String
     */
    public String toString() {

        return "TradePosition Id: " + this.getId() + " Version: " + this.getVersion()
                + " positionOpenDate: " + this.getPositionOpenDate() + " positionCloseDate: "
                + this.getPositionCloseDate() + " Side: " + this.getSide() + " Open Qty: " + this.getOpenQuantity()
                + " Total Buy qty: " + this.getTotalBuyQuantity() + " Total Buy Value: "
                + new Money(this.getTotalBuyValue()) + " Total Sell qty: " + this.getTotalSellQuantity()
                + " Total Sell Value: " + new Money(this.getTotalSellValue()) + " Total Comm: "
                + new Money(this.getTotalCommission()) + " updateDate: " + this.getLastUpdateDate();
    }
}
